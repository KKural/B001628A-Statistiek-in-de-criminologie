---
title: "Dodona Exercises — Combined (learnr)"
author: "UGent — Statistiek in de criminologie 1"
output: learnr::tutorial
runtime: shiny_prerendered
description: |
  Automatically aggregates your existing Dodona exercises into a single
  learnr tutorial by reading each description.nl.md and matching Answer.R.
  Where an MCQ can be parsed, options are clickable; if not, a short-answer
  fallback is used. Use this as an interactive catalog.
---

```{r setup, include=FALSE}
library(learnr)
library(stringi)
library(htmltools)
knitr::opts_chunk$set(echo = FALSE)

# Helpers ---------------------------------------------------------------
read_text <- function(path) {
  tryCatch(paste(readLines(path, warn = FALSE, encoding = "UTF-8"), collapse = "\n"),
           error = function(e) "")
}

parse_mcq_options <- function(desc_text) {
  # Capture lines like: "1. Text", "2. Text" (allow trailing two spaces)
  lines <- unlist(strsplit(desc_text, "\n"))
  # Remove markdown bold and italics for options extraction safety
  lines <- gsub("[*_`]+", "", lines)
  opt_idx <- grep("^[ ]{0,3}[0-9]+[.)][ ]+", lines)
  if (length(opt_idx) == 0) return(NULL)
  opts <- sub("^[ ]{0,3}([0-9]+)[.)][ ]+", "", lines[opt_idx])
  idxs <- as.integer(sub("^[ ]{0,3}([0-9]+)[.)].*", "\\1", lines[opt_idx]))
  # Return ordered by index
  ord <- order(idxs)
  list(text = opts[ord], index = idxs[ord])
}

extract_hint <- function(desc_text) {
  m <- regexpr("\\*\\*Hint\\*\\*: *([\n\r\t\s\S]*)$", desc_text)
  if (m[1] > 0) {
    # Pull line after **Hint:** if present, else empty
    lines <- unlist(strsplit(substr(desc_text, attr(m, "capture.start"), nchar(desc_text)), "\n"))
    if (length(lines) > 0) return(lines[1])
  }
  ""
}

extract_correct_from_answerR <- function(path) {
  # Heuristic: look for a numeric expected argument near a comment "Correct"
  txt <- read_text(path)
  m <- regexec(
    ",\s*([0-9]+(?:\\.[0-9]+)?)\s*,\s*#\s*Correct",
    txt
  )
  reg <- regmatches(txt, m)[[1]]
  if (length(reg) > 1) return(suppressWarnings(as.numeric(reg[2])))
  # Fallback: first numeric after testEqual(
  m2 <- regexec("testEqual\s*\([^,]+,[^,]+,\s*([0-9]+(?:\\.[0-9]+)?)", txt)
  reg2 <- regmatches(txt, m2)[[1]]
  if (length(reg2) > 1) return(suppressWarnings(as.numeric(reg2[2])))
  NA_real_
}

mk_question <- function(title, desc_text, answer_path) {
  opts <- parse_mcq_options(desc_text)
  correct_idx <- if (!is.null(answer_path) && file.exists(answer_path)) extract_correct_from_answerR(answer_path) else NA_real_
  # Create question object
  if (!is.null(opts) && length(opts$text) > 0 && !is.na(correct_idx)) {
    answers <- Map(function(opt_text, idx) {
      learnr::answer(opt_text, correct = isTRUE(idx == correct_idx))
    }, opts$text, opts$index)
    do.call(learnr::question, c(list(title), answers, list(allow_retry = TRUE, random_answer_order = FALSE)))
  } else {
    # Fallback short answer
    learnr::question_text(
      title,
      answer("", correct = TRUE),
      allow_retry = TRUE,
      placeholder = "Schrijf je antwoord in 1–2 zinnen of geef het cijfer."
    )
  }
}

find_exercises <- function() {
  desc_paths <- list.files(pattern = "^description\\.nl\\.md$", recursive = TRUE, full.names = TRUE)
  # Keep only those under a folder named "description"
  desc_paths <- desc_paths[grepl("\\/description\\/description\\.nl\\.md$|\\\\description\\\\description\\.nl\\.md$", desc_paths)]
  # Map to base exercise dir and Answer.R
  df <- data.frame(
    desc = desc_paths,
    stringsAsFactors = FALSE
  )
  df$exercise_dir <- normalizePath(file.path(dirname(df$desc), ".."), winslash = "/", mustWork = FALSE)
  df$title <- basename(df$exercise_dir)
  df$answer <- normalizePath(file.path(df$exercise_dir, "evaluation", "Answer.R"), winslash = "/", mustWork = FALSE)
  df
}

ex_df <- find_exercises()
```

## Overzicht

Deze interactieve catalogus bundelt je bestaande Dodona‑oefeningen. Voor elke oefening tonen we de opgave (NL) en — waar mogelijk — meerkeuzeopties met automatische nazicht. Als de juiste optie niet betrouwbaar uit `Answer.R` kan worden afgeleid, krijg je een kort‑antwoord vak (docent kan dit snel aanpassen).

```{r}
# Build quizzes grouped in the order discovered (you can reorder by title)
qlist <- list()
for (i in seq_len(nrow(ex_df))) {
  desc_text <- read_text(ex_df$desc[i])
  title <- sprintf("%s", ex_df$title[i])
  # Prefer the first paragraph as the stem; otherwise use full text
  stem <- strsplit(desc_text, "\n\n")[[1]]
  stem1 <- if (length(stem) > 0) stem[[1]] else desc_text
  qtitle <- paste0(title, " — vraag")
  qobj <- mk_question(qtitle, desc_text, ex_df$answer[i])
  # Wrap each question in its own section header
  qlist[[length(qlist) + 1]] <- tags$div(tags$h3(title), tags$p(stem1), qobj)
}
qlist
```

### Opmerkingen voor docenten

- MCQ‑detectie: zoekt genummerde regels ("1. ", "2. ") in `description.nl.md` en een verwacht index‑cijfer in `evaluation/Answer.R`.
- Als parsing faalt, tonen we een kort‑antwoord vak dat je later kunt omzetten naar MCQ.
- Dodona‑specifieke toleranties (±0.01) en geavanceerde feedback blijven in Dodona; dit bestand is een begeleidende, interactieve reader.

